import math

import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.nn.init import kaiming_uniform_

from lizrd.core.misc import Linear
from lizrd.support import ash
from research.reinitialization.pruner import Pruner


class RandomUnstructRecycleFF(nn.Module):
    """Feedforward layer with recycling"""
    def __init__(self, dmodel: int, dff: int, pruner: Pruner):
        super().__init__()
        self.lin1 = Linear(dmodel, dff)
        self.lin2 = Linear(dff, dmodel)
        pruner.register(self)

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        x = self.lin1(x)
        x = F.relu(x)
        x = self.lin2(x)
        return x

    def prune(self, prob: float):
        self._recycle_linear(self.lin1, prob)
        self._recycle_linear(self.lin2, prob)

    def _recycle_linear(self, layer: Linear, prob: float):
        # create mask and new_weights
        mask = torch.ones(layer.weight.size())
        new_weights = kaiming_uniform_(torch.empty_like(layer.weight), a=math.sqrt(5))
        new_weights *= 3 ** 0.5

        # prepare mask according to prob
        probs = torch.rand_like(mask)
        mask[probs <= prob] = 0

        # apply mask to weights
        layer.weight.data = mask * layer.weight.data + (1 - mask) * new_weights


class RandomStructRecycleFF(nn.Module):
    """Feedforward layer with recycling"""
    def __init__(self, dmodel: int, dff: int, pruner: Pruner):
        super().__init__()
        self.lin1 = Linear(dmodel, dff)
        self.lin2 = Linear(dff, dmodel)
        self.dff = dff
        pruner.register(self)

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        x = self.lin1(x)
        x = F.relu(x)
        x = self.lin2(x)
        return x

    def prune(self, prob: float):
        # create mask
        mask = torch.eye(self.dff)
        diag = torch.diag(mask)

        # prepare mask according to prob
        probs = torch.rand_like(diag)
        diag[probs <= prob] = 0

        # apply mask to lin1
        # TODO: also reset bias
        new_weights = kaiming_uniform_(torch.empty_like(self.lin1.weight), a=math.sqrt(5))
        new_weights *= 3 ** 0.5
        self.lin1.weight.data = mask @ self.lin1.weight.data + (1 - mask) @ new_weights

        # apply mask to lin2
        new_weights = kaiming_uniform_(torch.empty_like(self.lin2.weight), a=math.sqrt(5))
        new_weights *= 3 ** 0.5
        self.lin1.weight.data = self.lin2.weight.data @ mask + new_weights @ (1 - mask)
